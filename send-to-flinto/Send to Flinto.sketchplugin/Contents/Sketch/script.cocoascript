@import 'MochaJSDelegate.js'
@import 'ScreenTemplate.js'

var script_version = "1.4";
var doc, export_directory;
var export_scale_factor = 1.0;
var export_offset = 999999;

var send_to_flinto = function(context) {

  doc = context.document

  var artboards = Array.fromNSArray(doc.currentPage().artboards()).filter(is_artboard)
  var selectedArtboards = Array.fromNSArray(context.selection).filter(is_artboard)

  if (artboards.length == 0) {
    _alert("You need at least one artboard to export as a Flinto document.")
    return
  }

  var dialog = new Dialog()
  var msg = "Send Artboards to Flinto"

  var options = dialog.runModal(msg, artboards[0], selectedArtboards.length)

  if (options[0] != NSAlertFirstButtonReturn) { return; }
  export_scale_factor = options[1]
  resolution = options[2]
  pixelDensity = options[3]
  selectedOnly = options[4]

  export_directory = tempFolder()

  if (selectedOnly) {
    artboards = selectedArtboards
  }
  var fileManager = [NSFileManager defaultManager];

  var isDir = MOPointer.alloc().init();
  if ([fileManager fileExistsAtPath:export_directory isDirectory:isDir]) {
    if (isDir.value() == 0) {
      [fileManager removeItemAtPath:export_directory error:0];
    }
  }

  var artboard_metadata = [];

  var alert = [[NSAlert alloc] init];
  [alert setMessageText:"Sending to Flinto..."];
  [alert setInformativeText:""];

  var progress = [[NSProgressIndicator alloc] initWithFrame:CGRectMake(0, 0, 400, 50)]
  [progress setMaxValue:artboards.length]
  [progress setMinValue:0]
  [progress setDoubleValue:0];
  [progress setUsesThreadedAnimation:true];
  [progress startAnimation:nil];
  [progress setIndeterminate:false];
  [alert setAccessoryView:progress]


  var button = [alert addButtonWithTitle:"Cancel"];

  var index = artboards.length - 1;

  var processor = new MochaJSDelegate({
    "processArtboard:":(function(timer) {
      var artboard_label = artboards.length > 1 ? "artboards" : "artboard"
      var message  =  "Completed " + (artboards.length - index) + " out of " + artboards.length + " " + artboard_label + "."
      [alert setInformativeText: message];
      [progress setDoubleValue:artboards.length - index];
      artboard_metadata.push(process_artboard(artboards[index]))
      index -= 1
      if (index < 0) {
        timer.invalidate()
        [NSApp endSheet:alert.window()];
      }
    }),
  });

  var timer = [NSTimer scheduledTimerWithTimeInterval: 0.05 target: processor.getClassInstance() selector: "processArtboard:" userInfo: nil repeats: true]
  var runLoop = [NSRunLoop currentRunLoop];
  [runLoop addTimer:timer forMode:NSRunLoopCommonModes];
  var responseCode = [alert runModal];
  if (responseCode == 1000) {
    return
  }

  // Write JSON

  var json = {
    scale:pixelDensity,
    width:resolution.width,
    height:resolution.height,
    screens:artboard_metadata,
    "id":doc.currentPage().objectID(),
    version:"script_version"
  };

  var metadataJSON = [NSJSONSerialization dataWithJSONObject:json options:NSJSONWritingPrettyPrinted error:nil];
  metadataJSON = [[NSString alloc] initWithData:metadataJSON encoding:NSUTF8StringEncoding];
  [metadataJSON writeToFile:export_directory + "/metadata.json" atomically:true encoding:NSUTF8StringEncoding error:null];

  log(artboards.length + " artboards exported: " + export_directory)

  workspace = [[NSWorkspace alloc] init];
  // [workspace selectFile:export_directory inFileViewerRootedAtPath:@""];
  [workspace openFile:export_directory];
};


var process_artboard = function(artboard) {

  // var layers_metadata = []
  var layers_metadata = Array.fromNSArray([artboard layers])
    .map(function(layer)   { return process_layer(layer, artboard)    })
    .filter(function(elem) { return elem != undefined && elem != nil  })

  var r = artboard.absoluteRect()

  var bg = artboard_background(artboard)
  if (bg != nil) {
    layers_metadata.unshift(bg)
  }

  return {
    'layers':layers_metadata,
    'id':artboard.objectID(),
    'name':artboard.name(),
    'x':(r.x()) * export_scale_factor,
    'y':(r.y()) * export_scale_factor,
    'w':(r.width()) * export_scale_factor,
    'h':(r.height()) * export_scale_factor,
  }
};

//
// process layer
//
var process_layer = function(layer, artboard) {
  var layer_data;

  // Ignore hidden layer
  if ([layer isVisible] == 0) {
    return nil
  }
  if (should_ignore_layer(layer)) {
    return nil
  }
  if (is_slice(layer)) {
    return nil
  }

  var processing_symbol = false
  if (is_symbol_instance(layer)) {
    var originalID = layer.objectID()
    layer = [[layer duplicate] detachByReplacingWithGroup]
    // Ref #2148 calling `detachByReplacingWithGroup` on empty symbol returns nil
    if (layer == nil) {
      return nil
    }
    [layer setObjectID:originalID]
    processing_symbol = true
  }

  if (is_group(layer) && should_flatten_layer(layer) == false && layer.rotation() == 0) {
    var sublayers = [layer layers];
    var layers_holder = []
    // Sketch returns sublayers in reverse, so we'll iterate backwards
    for (var sub= 0; sub < [sublayers count] ; sub++) {
      var current = [sublayers objectAtIndex:sub];

      var clipping = current.hasClippingMask()

      if (is_mask_group(current) || clipping) {
        if ([current isVisible] == 0) {
          continue
        }

        if (clipping) {
          var d = export_mask_layer(layer, sub, artboard)
        }
        else {
          var d = export_mask_layer(current, 0, artboard)
        }
        if (d != undefined) {
          layers_holder.push(d)
        }
        if (clipping) {
          break
        }
      }
      else {
        var d = process_layer(current, artboard)
        if (d != undefined) {
          layers_holder.push(d);
        }
      }
    }

    layer_data = metadata_for(layer, layer, artboard);
    layer_data.type = "group"
    layer_data.layers = layers_holder;

  }
  else {
    var e = export_layer(layer, artboard);
    if (e != undefined) {
      layer_data = e;
    }
  }

  if (processing_symbol) {
    [layer removeFromParent]
  }

  return layer_data;
}

var duplicate_and_process_layer = function(layer, callback) {

  // Copy off-screen, out of artboard so it is not masked by artboard
  var clone = [layer duplicate];

  try {

    var originalOpacity = layer.style().contextSettings().opacity()
    if (originalOpacity != 1) {
      clone.style().contextSettings().setOpacity(1)
    }
    clone.setRotation(0)
    [clone removeFromParent];
    [[doc currentPage] addLayers: [clone]];
    var frame = [clone frame];
    [frame setX: export_offset];
    [frame setY: export_offset];

    var result = callback(clone)

    if (originalOpacity != clone.style().contextSettings().opacity()) {
      clone.style().contextSettings().setOpacity(originalOpacity)
    }

    [clone removeFromParent];

    return result
  }
  catch (e) {
    // Make sure to remove cloned layer
    try { [clone removeFromParent]; } catch (e) {}
    throw e
  }

}

var export_mask_layer = function(layer, mask_index, artboard) {

  // if (mask_index == layer.layers().count() - 1) {
  //   log("Ignore mask on top of group")
  //   return nil
  // }
  return duplicate_and_process_layer(layer, function(layer_copy) {

    var sublayers = [layer_copy layers]
    var mask_layer = [sublayers objectAtIndex:mask_index];

    // Hide layers below mask layer
    var toBeHidden = []
    for (var i = 0; i < mask_index; ++i) {
      var l = [sublayers objectAtIndex:i];
      if ([l isVisible] != 0) {
        toBeHidden.push(l);
      }
    }
    for (var i = 0; i < toBeHidden.length; ++i) {
      toBeHidden[i].setIsVisible(0);
    }

    layer_data = metadata_for(layer, layer_copy, artboard);
    layer_data.type = "image";
    layer_data["id"] = layer.objectID()

    var path_to_file = export_directory + "/" + artboard.objectID() + "/" + [layer objectID] + ".png";
    export_as_slice(layer_copy, path_to_file)

    for (var i = 0; i < toBeHidden.length; ++i) {
      toBeHidden[i].setIsVisible(1);
    }

    return layer_data

  })

}

var export_layer = function(layer, artboard) {

  var d = rectangle_layer_data(layer, artboard)

  if (d != nil) {
    return d
  }

  var path_to_file = export_directory + "/" + artboard.objectID() + "/" + [layer objectID] + ".png";

  // Disable this for now...
  //
  // if (is_bitmap(layer)) {
  //   var layer_data = metadata_for(layer, layer, artboard);
  //   layer_data.type = "image";
  //   [[[layer image] data] writeToFile:path_to_file atomically:true];
  //   return layer_data;
  // }


  return duplicate_and_process_layer(layer, function(layer_copy) {

    var layer_data = metadata_for(layer, layer_copy, artboard);
    layer_data.type = "image";
    export_as_slice(layer_copy, path_to_file)

    return layer_data;

  })
}

var export_rect = function(layer) {
  if (is_group(layer)) {
    var rects = []
    var sublayers = [layer layers];
    if ([sublayers count] == 0) {
      return export_rect_impl(layer)
    }
    for (var sub= 0; sub < [sublayers count] ; sub++) {
      var child = [sublayers objectAtIndex:sub];
      rects.push(export_rect(child))
    }
    var r = rects[0]
    for (var i = 1; i < rects.length; i++) {
      r = CGRectUnion(r, rects[i])
    }
    return r
  }
  else {
    return export_rect_impl(layer)
  }
}

var export_rect_impl = function(layer) {
  if (is_text(layer)) {
    if ([MSSliceTrimming respondsToSelector:"trimmedRectForLayerAncestry:"]) {
      return [MSSliceTrimming trimmedRectForLayerAncestry:[MSImmutableLayerAncestry ancestryWithMSLayer:layer]];
    }
    else {
      return [MSSliceTrimming trimmedRectForSlice:layer];
    }
  }
  else {
    return [layer absoluteInfluenceRect];

  }
}

var export_as_slice = function(layer, path) {
  // var slice = [MSExportRequest requestWithRect:export_rect(layer) scale:export_scale_factor];
  var slice = [MSExportRequest new]
  slice.rect = export_rect(layer)
  slice.scale = export_scale_factor
  [doc saveArtboardOrSlice:slice toFile:path];
}

var metadata_for = function(layer, layer_copy, artboard) {

  var er = [MSRect rectWithRect:export_rect(layer_copy)];
  var ero = [layer_copy absoluteRect];

  var diff = {
    x: (ero.x() + ero.width()/2) - (er.x() + er.width() / 2),
    y: (ero.y() + ero.height()/2) - (er.y() + er.height() / 2)
  }

  var lr = [layer absoluteRect];
  var ar = [artboard absoluteRect];

  center = {
    x: (lr.x() - ar.x() - diff.x) + lr.width() / 2,
    y: (lr.y() - ar.y() - diff.y) + lr.height() / 2,
  }

  if (layer == layer_copy) {
    center = {
      x: (lr.x() - ar.x()) + lr.width() / 2,
      y: (lr.y() - ar.y()) + lr.height() / 2,
    }
    er = layer.frame()
  }

  var ret = {
    x: center.x * export_scale_factor,
    y: center.y * export_scale_factor,
    w: er.width()  * export_scale_factor,
    h: er.height() * export_scale_factor,
    rotation:layer.rotation(),
    opacity: layer.style().contextSettings().opacity(),
    "id": layer.objectID(),
    name : [layer name],
    locked: [layer isLocked]
  };

  return ret
}

var is_group = function(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]] || [layer isMemberOfClass:[MSSymbolMaster class]]
}

var is_mask_group = function(layer) {
  if (is_group(layer) && layer.layers().count() > 0) {
    var clip = layer.layers().objectAtIndex(0)
    if (clip.hasClippingMask()) {
      return true
    }
  }
  return false
}

var is_symbol_instance = function(layer) {
  return [layer isMemberOfClass:[MSSymbolInstance class]]
}

var is_text = function(layer) {
  return [layer isMemberOfClass:[MSTextLayer class]]
}

var is_slice = function(layer) {
  return [layer isMemberOfClass:[MSSliceLayer class]]
}

var is_artboard = function(layer) {
  return [layer isMemberOfClass:[MSArtboardGroup class]];
}

var is_bitmap = function(layer) {
  return [layer isMemberOfClass:[MSBitmapLayer class]];
}

var should_ignore_layer = function(layer) {
  return !![layer name].match(/\-flinto$/)
}

var should_flatten_layer = function(layer) {
  if (!![layer name].match(/\+flinto$/)) {
    return true
  }
  var sublayers = [layer layers];
  for (var sub= 0; sub < [sublayers count] ; sub++) {
    var child = [sublayers objectAtIndex:sub];
    if (is_group(child) || is_symbol_instance(child)) {
      return false
    }
  }
  return true
}


var color_data = function(color) {
  return {
    "r": [color red],
    "g": [color green],
    "b": [color blue],
    "a": [color alpha]
  };
}



//
// Export rectangle
//
var rectangle_layer_data = function(layer, artboard) {

  var style = [layer style];
  var layer_data = {}

  var enabled_style = function(styleCollection) {
    var arr
    try {
      arr = Array.fromNSArray(styleCollection.array())
    }
    catch (e) {
      arr = Array.fromNSArray(styleCollection)
    }
    return arr.filter(function(style) { return style.isEnabled()})
  }

  var enabledBorders = enabled_style([style borders]);
  var enabledFills = enabled_style([style fills]);
  var enabledShadows = enabled_style([style shadows])

  if (layer.hasClippingMask()) {
    return nil
  }

  // multiple borders, or shadows
  if (enabledBorders.length > 1 || enabledShadows.length > 1) {
    return nil;
  }

  // Unsupported border options
  if ([style startDecorationType] != 0 || [style endDecorationType] != 0 || [[style borderOptions] hasDashPattern]) {
    return nil;
  }

  if ([[style blur] isEnabled]) {
    return nil
  }

  // Multiple fills, or inneshadow
  if (enabledFills.length > 1 || (enabled_style([style innerShadows]).length > 0)) {
    return nil;
  }

  if ([layer isMemberOfClass:[MSShapeGroup class]]) {
    var paths = [layer layers];
    if ([paths count] != 1) {
      return nil;
    }

    var shape = [paths firstObject];

    if ([shape isMemberOfClass:[MSRectangleShape class]]) {
      if ([[shape cornerRadiusString] containsString:"/"]) {
        return nil;
      }
      else if ([shape edited]) {
        return nil
      }
      else {
        layer_data.cornerRadius = [shape cornerRadiusFloat] * export_scale_factor;
      }
    }
    else if ([shape isMemberOfClass:[MSOvalShape class]]) {
      var frame = [shape frame]
      if (Math.abs([frame width] - [frame height] < 1)) {
        layer_data.cornerRadius = [frame width]/2 * export_scale_factor;
      }
      else {
        return nil
      }
    }
    else {
      return nil;
    }

    if (enabledFills.length == 1) {
      var firstFill = enabledFills[0];
      if ([firstFill fillType] == 0) {
        layer_data.fillColor = color_data([firstFill colorGeneric])
      }
      else {
        return nil
      }
    }
  }
  else {
    return nil;
  }


  if (enabledBorders.length == 1) {
    var border = enabledBorders[0]
    if ([border fillType] == 0) {
      layer_data.borderColor = color_data([border colorGeneric])
      layer_data.borderWidth = [border thickness] * export_scale_factor
      var pos = [border position]
      if (pos == 0) {
         layer_data.borderType = 1
      } else if (pos == 1) {
         layer_data.borderType = 0
      } else if (pos == 2) {
         layer_data.borderType = 2
      }
    }
    else {
      return nil
    }
  }

  if (enabledShadows.length == 1) {
    var shadow = enabledShadows[0]
    layer_data.shadowColor = color_data([shadow colorGeneric])
    layer_data.shadowOffsetX = [shadow offsetX] * export_scale_factor
    layer_data.shadowOffsetY = [shadow offsetY] * export_scale_factor
    layer_data.shadowBlur    = [shadow blurRadius] * export_scale_factor
    layer_data.shadowSpread  = [shadow spread] * export_scale_factor
  }

  var m = metadata_for(layer, layer, artboard)
  m.style = layer_data
  m.type = "rectangle"
  return m

}

var artboard_background = function(artboard)  {

  if ([artboard hasBackgroundColor] && [artboard includeBackgroundColorInExport]) {
    var artboard_data = {fillColor: color_data([artboard backgroundColorGeneric])}

    var ar = [artboard absoluteRect];

    center = {x: ar.width() / 2, y: ar.height() / 2}

    return {
      x: center.x * export_scale_factor,
      y: center.y * export_scale_factor,
      w: ar.width()  * export_scale_factor,
      h: ar.height() * export_scale_factor,
      "id": artboard.objectID() + "-BG",
      name : "Background",
      style:artboard_data,
      type:"rectangle"
    };
  }
  else {
    return nil
  }
}


//
//
//
// Export Dialog
//
//
//


var tempFolder = function() {

  globallyUniqueString = [[NSProcessInfo processInfo] globallyUniqueString];
  tempDirectoryPath = NSTemporaryDirectory()
  tempDirectoryPath = [tempDirectoryPath stringByAppendingPathComponent:globallyUniqueString];
  var name = [doc displayName].replace(/\.sketch$/, '') + '.flinto';
  tempDirectoryPath = [tempDirectoryPath stringByAppendingPathComponent:name];
  tempDirectoryURL = [NSURL fileURLWithPath:tempDirectoryPath isDirectory:true];
  [[NSFileManager defaultManager] createDirectoryAtURL:tempDirectoryURL withIntermediateDirectories:true attributes:nil error:nil];

  return tempDirectoryPath;
}


var createLabel = function(text, rect) {
  var label = [[NSTextField alloc] initWithFrame:rect]
  label.stringValue = text
  label.editable = false
  label.borderd = false
  label.bezeled = false
  label.setAlignment(1)
  label.useSingleLineMode = true
  label.drawsBackground = false
  return label
}

var Dialog = function() {}

Dialog.prototype.runModal = function(msg, artboard, selectedCount) {

  this.artboard = artboard

  var suggestedScaleFactor = 1.0
  this.isLandscape = false

  var r = this.artboard.absoluteRect()
  this.initialSize = {width:r.width(), height:r.height()}

  var resolutionLabel = createLabel("Scale", NSMakeRect(16, 122, 94, 17))
  var combobox = [[NSPopUpButton alloc] initWithFrame:NSMakeRect(118, 116, 165, 26)];

  this.combobox = combobox
  var obj = this;

  var scaleItemCallback = function(item) {
      obj.updateSizeTextField()
  }

  var scales = ["50%", "100%", "150%", "200%", "300%"];
  scales.forEach(function(elem) {
    var item = [[NSMenuItem alloc] initWithTitle:elem action: "didChooseTemplate" keyEquivalent: ""]
    item.representedObject = elem
    [item setCOSJSTargetFunction:scaleItemCallback]
    [[combobox menu] addItem:item];
  })



  var menuItemCallback = function(item) {
    var tmpl = item.representedObject()
    var w = tmpl["width"]
    var h = tmpl["height"]
    var density = tmpl["density"]
    if (w != 0 && h != 0) {
      obj.initialSize.width = w / density
      obj.initialSize.height = h / density
      var scaleFactorIndexs = [0, 1, 3, 4];
      [combobox selectItemAtIndex:scaleFactorIndexs[density]]
      obj.isLandscape = false
      obj.updateSizeTextField()
    }
  }


  var setInitialSize = false
  var pixelDensity = 1.0

  var deviceLabel = createLabel("Device Size", NSMakeRect(16, 81, 94, 17))
  var dropdown = [[NSPopUpButton alloc] initWithFrame:NSMakeRect(116, 76, 167, 26)]
  for (index in screenTemplate) {
    var category = screenTemplate[index]
    [[dropdown menu] addItemWithTitle:category["category"] action: "" keyEquivalent: ""]

    for (var i in category["templates"]) {
      var tmpl = category["templates"][i]
      var item = [[NSMenuItem alloc] initWithTitle:tmpl["name"] action: "didChooseTemplate" keyEquivalent: ""]
      item.indentationLevel = 1
      item.representedObject = tmpl
      [item setCOSJSTargetFunction:menuItemCallback]
      [[dropdown menu] addItem:item];

      if (setInitialSize == false) {
        var width = tmpl["width"]
        var height = tmpl["height"]

        if (r.width() == width || r.width() * 2 == width || r.width() * 3 == width ) {
          [dropdown selectItem:item]
          suggestedScaleFactor = width / r.width()
          pixelDensity = tmpl["density"]
          this.initialSize = {width:(width / suggestedScaleFactor), height:(height / suggestedScaleFactor)}
          setInitialSize = true
        }
        if (r.width() == height || r.width() * 2 == height || r.width() * 3 == height)  {
          this.isLandscape = true
          [dropdown selectItem:item]
          suggestedScaleFactor = height / r.width()
          this.initialSize = {width:(width / suggestedScaleFactor), height:(height / suggestedScaleFactor)}
          pixelDensity = tmpl["density"]
          setInitialSize = true
        }
      }

    }

    [[dropdown menu] addItem:[NSMenuItem separatorItem]]

  }

  var item = [[NSMenuItem alloc] initWithTitle:"Custom" action: "didChooseTempalte" keyEquivalent: ""]
  item.representedObject = {"name":"Custom", "width":0, "height":0}
  [item setCOSJSTargetFunction:menuItemCallback]
  [[dropdown menu] addItem:item];

  if (setInitialSize == false) {
    [dropdown selectItem:item]
  }


  var widthField = [[NSTextField alloc] initWithFrame:CGRectMake(118, 39, 75, 22)]
  var heightField = [[NSTextField alloc] initWithFrame:CGRectMake(205, 39, 75, 22)]

  this.widthField = widthField
  this.heightField = heightField

  var widthLabel = createLabel("Width", CGRectMake(118, 21, 75, 18))
  [widthLabel setAlignment:2]
  [widthLabel setFont:[NSFont systemFontOfSize:[NSFont smallSystemFontSize]]]
  var heightLabel = createLabel("Height", CGRectMake(205, 21, 75, 18))
  [heightLabel setFont:[NSFont systemFontOfSize:[NSFont smallSystemFontSize]]]
  [heightLabel setAlignment:2]

  var checkBox = [[NSButton alloc] initWithFrame:CGRectMake(38, 0, 250, 18)]
  [checkBox setButtonType:NSSwitchButton];
  // [checkBox setObjectValue:flag[@"id"]];
  [checkBox setState:false];
  [checkBox setTitle:@"Export only selected artboards"];
  if (selectedCount == 0) {
    [checkBox setEnabled:false];
  }
  else {
    [checkBox setState:true];
  }

  var scaleFactorIndex = 1;
  if (suggestedScaleFactor > 1) {
    var index = parseInt(suggestedScaleFactor);
    var scaleFactorIndexs = [1, 1, 3, 4];
    if (index < 4) {
      scaleFactorIndex = scaleFactorIndexs[index];
    }
  }
  [combobox selectItemAtIndex:scaleFactorIndex];
  this.scaleFactor = parseFloat([combobox stringValue].replace(/[^0-9]/g,"")) / 100;

  this.updateSizeTextField()


  var view = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 300, 150)]
  [view addSubview:deviceLabel]
  [view addSubview:resolutionLabel]
  [view addSubview:combobox]
  [view addSubview:dropdown]

  [view addSubview:this.widthField]
  [view addSubview:this.heightField]
  [view addSubview:widthLabel]
  [view addSubview:heightLabel]
  [view addSubview:checkBox]

  var alert = [[NSAlert alloc] init];
  [alert setMessageText:msg];
  [alert addButtonWithTitle:'Send'];
  [alert addButtonWithTitle:'Cancel'];
  [alert setAccessoryView:view];

  [widthField setNextKeyView:heightField];
  [heightField setNextKeyView:widthField];

  var responseCode = [alert runModal];

  var scale = parseFloat([combobox representedObject].replace(/[^0-9]/g,"")) / 100;
  var deviceType = [dropdown indexOfSelectedItem]
  var selectedOnly = [checkBox state];

  var gs = [[NSLocale currentLocale] objectForKey:NSLocaleGroupingSeparator];
  var ds = [[NSLocale currentLocale] objectForKey:NSLocaleDecimalSeparator];


  var width  = this.widthField.stringValue().replace(gs, "").replace(ds, ".")
  var height = this.heightField.stringValue().replace(gs, "").replace(ds, ".")
  resolution = {"width":parseFloat(width), "height":parseFloat(height)}
  log(resolution.width + "x" +  resolution.height + "@" + scale + "x " + pixelDensity)


  return [responseCode, scale, resolution, pixelDensity, selectedOnly];

}

Dialog.prototype.updateSizeTextField = function() {
  var index = this.deviceSelectedIndex
  var wField = this.widthField
  var hField = this.heightField

  var r = this.initialSize
  var w = r.width
  var h = r.height

  if (this.isLandscape) {
    tmp = w
    w = h
    h = tmp
  }

  var combobox = this.combobox
  var s = parseFloat([combobox representedObject].replace(/[^0-9]/g,"")) / 100;

  [wField setStringValue:w * s];
  [hField setStringValue:h * s];
}

//
// Some utilities
//

Array.fromNSArray = function(nsa) {
  var ret = []
  for (i = 0; i < nsa.count(); ++i) {
    ret.push(nsa.objectAtIndex(i))
  }
  return ret;
}

var _alert = function(message, informativeText) {
  var alert = [[NSAlert alloc] init];
  [alert setMessageText:message];
  [alert addButtonWithTitle:"Dismiss"];
  if (informativeText != undefined) {
    [alert setInformativeText:informativeText]
  }
  [alert runModal]
}

var onRun = function(context) {

  try {
    send_to_flinto(context)
  }
  catch (e) {
    log(e)
    _alert("Something went wrong with the plugin.", e.message)
  }

}

